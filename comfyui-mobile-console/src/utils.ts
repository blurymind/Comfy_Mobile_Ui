export const COMFY_UI_PORT = 8188;
export const COMFY_UI_URL = `http://${window.location.hostname}:${COMFY_UI_PORT}`;
export const seed = () => {
	return Math.floor(Math.random() * 9999999999);
};
//@ts-ignore
export const uuidv4 = () => {
	//@ts-ignore
	return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(
		/[018]/g,
		//@ts-ignore
		(c) =>
			(
				c ^
				(crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
			).toString(16),
	);
};
export const CLIENT_ID = uuidv4();
export const SERVER_ADDRESS = window.location.hostname + ":" + COMFY_UI_PORT;
export const PROMPT_TIME = 1000;
export let fetched = false; // to prevent react from creating two websockets at the useEffect mount
export const load_api_workflows = (onDone: any) => {
	if (fetched) return;
	console.log("Fetching workflows...");
	fetched = true;
	fetch("/fireplace/workflows.json")
		.then((res) => res.json())
		.then((data) => {
			console.log("---- received workflows!");
			onDone(data);
		}); // generated by the pyton server
};
export const PROTOCOL = window.location.protocol === "https:" ? "wss:" : "ws:";

export const queue_prompt = async (prompt = {}) => {
	const data = { prompt: prompt, client_id: CLIENT_ID };

	console.log("Prompt ");
	const response = await fetch(`http://${SERVER_ADDRESS}/prompt`, {
		method: "POST",
		cache: "no-cache",
		headers: {
			"Content-Type": "application/json",
		},
		body: JSON.stringify(data),
	});

	return await response.json();
};
// @ts-ignore
export const getWorkflowPromptNode = (workflow: any): any => {
	const node = Object.entries(workflow).find(([_, node]) => {
		if (
			//@ts-ignore
			node.class_type === "CLIPTextEncode" &&
			//@ts-ignore
			!node.inputs.text.toLowerCase().startsWith("negative")
		) {
			//   key = nodeKey;
			return true;
		}
		return false;
	});
	return node;
};

// @ts-ignore
export const getSeedNodeKey = (altWorkflow: any): any => {
	const result = Object.entries(altWorkflow).find(([_, node]) => {
		if (
			//@ts-ignore
			node.class_type === "RandomNoise" &&
			//@ts-ignore
			"noise_seed" in node.inputs
		) {
			return true;
		}
		if (
			//@ts-ignore
			node.class_type === "KSampler" &&
			//@ts-ignore
			"seed" in node.inputs
		) {
			return true;
		}
		return false;
	}) ?? ["0"];

	// console.log({ result, altWorkflow });
	return result[0]; // {...result, noise_seed: seed};
};

export const getMutatedWorkflow = (workflow: any, prompt: string) => {
	const [textNodeKey] = getWorkflowPromptNode(workflow);
	const seedNodeKey = getSeedNodeKey(workflow);
	return {
		...workflow,
		[textNodeKey]: {
			...workflow[textNodeKey],
			inputs: { ...workflow[textNodeKey].inputs, text: prompt },
		},
		[seedNodeKey]: {
			...workflow[seedNodeKey],
			inputs: { ...workflow[seedNodeKey].inputs, noise_seed: seed() },
		},
	};
};
export const getWorkflowText = (workflow: any) => {
	const [_, workflowNode] = getWorkflowPromptNode(workflow);
	// console.log({ workflowNode });
	if (!workflowNode) return "";
	//@ts-ignore
	return workflowNode.inputs.text;
};
export const getInput = (query: string, sufixWorkflowText: string) => {
	return query.replace(/(\r\n|\n|\r|\")/gm, " ") + "," + sufixWorkflowText;
};


export const socket = new WebSocket(
	PROTOCOL + "//" + SERVER_ADDRESS + "/ws?clientId=" + CLIENT_ID,
);

// export const initialiseListeners = ({
// 	resultContainerRef,
// 	setCount,
// 	isGenerating,
// 	setProgress,
// 	setResults,
// 	results,
// 	count,
// 	promptTags,
// 	setIsGenerating,
// }: any) => {
// 	// socket.addEventListener("open", (event) => {
// 	// 	console.log("============ Connected to the server", { event });
// 	// });
// 	console.log("========= ADD LISTENER", { socket });
// 	const onMessage = (event: any) => {
// 		const data = JSON.parse(event.data);
// 		// console.log("---", data);
// 		if (data.type === "progress") {
// 			// setIsGenerating(true);
// 			setProgress(data["data"]["max"] - data["data"]["value"]);
// 			// console.info(data["data"]["max"], data["data"]["value"]);

// 			// updateProgress(data['data']['max'], data['data']['value']);
// 		} else if (data.type === "executed" && count === 0 && !isGenerating) {
// 			const execution_time = 22; //elapsedTime();
// 			// console.log("Execution time: " + execution_time + "s", {
// 			// 	isGenerating,
// 			// 	progress,
// 			// });
// 			if ("images" in data["data"]["output"]) {
// 				const imageData = data["data"]["output"]["images"];
// 				if (imageData[0]?.type === "temp") {
// 					// console.log(" -- SKIP --");
// 					return;
// 				}
// 				// console.log({ imageData, results, isGenerating });
// 				const loras = ""; //getLoras();
// 				const models = ""; //getModels();
				
// 				const nextResults: any = [...results]
// 				imageData.forEach((item: any) => nextResults.push({
// 					filename: item.filename,
// 					subfolder: item.subfolder,
// 					random: Math.random(),
// 					tags: promptTags.map((item: any) => item.value).join(","),
// 					models,
// 					loras,
// 				}))


// 				// 	...results,
// 				// 	...imageData
// 				// 		.filter(
// 				// 			(item: any) => !item.filename.toLowerCase().includes("_temp_"),
// 				// 		)
// 						// .map((item: any) => ({
// 						// 	filename: item.filename,
// 						// 	subfolder: item.subfolder,
// 						// 	random: Math.random(),
// 						// 	tags: promptTags.map((item: any) => item.value).join(","),
// 						// 	models,
// 						// 	loras,
// 						// })),
// 				// ];
// 				console.log({ nextResults });
// 				setResults(nextResults);
// 				setIsGenerating(false);
// 				setTimeout(() => {
// 					if (resultContainerRef.current) {
// 						resultContainerRef.current.scrollTop =
// 							resultContainerRef.current.scrollHeight;
// 						// resultContainerRef.current.click();
// 					}
// 				}, 500);
// 			}
// 		} else if (data.type === "execution_interrupted") {
// 			console.log("Execution Interrupted");
// 			setCount(data["data"]["status"]["exec_info"]["queue_remaining"]);
// 		} else if (data.type === "status") {
// 			// console.log({ data });
// 			const remaining = data["data"]["status"]["exec_info"]["queue_remaining"];
// 			setIsGenerating(remaining > 0 ? true : false);
// 			setCount(remaining);
// 		}
// 	};
// 	socket.addEventListener("message", onMessage);
// };
